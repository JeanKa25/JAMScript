#!/usr/bin/env python
import kivy
from kivy.app import App
from kivy.uix.widget import Widget
from kivy.uix.label import Label
from kivy.graphics import Color, Rectangle, Line, Ellipse
from kivy.clock import Clock
from kivy.core.window import Window
from kivy.core.text import Label as CoreLabel

import argparse
import paho.mqtt.client as mqtt
import json
import math

from fabric import Connection
import time
import cartopy.crs as ccrs

from contextlib import ExitStack
from datetime import datetime

# Scale window with respect to these
WORLD_END_X = 17005833.33052523
WORLD_END_Y = 8625154.6651


#appName = "qwe"
appName = "jt1"

all_brokers = []

loc_scale = 1/10000
rect_scale = 0.4

display_distances = False
display_connections = True

pressed_keys = {}

# Choosing robinson projection
geodetic = ccrs.Geodetic()
robinson = ccrs.Robinson()

remote_host = None
remote_tunnels = []
remote_tunnel_context_stack = None
remote_connection = None

selected_broker = None

def cleanup_exit():
    for broker in all_brokers:
        broker['client'].disconnect()
    if remote_tunnel_context_stack:
        remote_tunnel_context_stack.close()
    exit(0)


def geo2Distance(pos1,pos2):
    lon1 = math.radians(pos1[0])
    lat1 = math.radians(pos1[1])
    lon2 = math.radians(pos2[0])
    lat2 = math.radians(pos2[1])
    
    R = 6378.137

    dist = math.acos(math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)) * R
    return dist * 1000

def geo2Distance_old(pos1, pos2):
    lon1 = pos1['long']
    lat1 = pos1['lat']
    lon2 = pos2['long']
    lat2 = pos2['lat']
    
    R = 6378.137
    dLat = lat2 * math.pi / 180 - lat1 * math.pi / 180
    dLon = lon2 * math.pi / 180 - lon1 * math.pi / 180
    a = math.sin(dLat/2) * math.sin(dLat/2) + math.cos(lat1 * math.pi / 180) * math.cos(lat2 * math.pi / 180) * math.sin(dLon/2) * math.sin(dLon/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d * 1000;

class main_canvas(Widget):
    def __init__(self, **kwargs):
        super(main_canvas, self).__init__(**kwargs)
        self.cycles = 0
        self.cycles_this_sec = 0;
        self.last_sec = time.time();
        self.underlying_scale = 1
        self.voff = 0
        self.hoff = 0
        self.width = 0
        self.height = 0
        self.bounding_boxes = []
        self._keyboard = Window.request_keyboard(self._keyboard_closed, self)
        self._keyboard.bind(on_key_down=self._on_keyboard_down)
        self._keyboard.bind(on_key_up=self._on_keyboard_up)
        self.dbgx = 0
        self.dbgy = 0
        Window.bind(on_resize=self.on_resize)
        Window.bind(on_mouse_down=self.on_mouse_down)
    
    def transform_loc_raw(self, pos_raw):
        pos = robinson.transform_point(pos_raw[0], pos_raw[1], geodetic)
        pos = (pos[0]*loc_scale, pos[1]*loc_scale)
        pos = (pos[0]+self.hoff, pos[1]+self.voff)
        return pos
        
    def transform_loc(self, loc):
        return self.transform_loc_raw((loc['long'],loc['lat']))

    def draw_centered_square(self, pos, colour, size):
        scaled_size = size*rect_scale
        Color(colour[0]/255, colour[1]/255, colour[2]/255, mode='rgb')
        centered_pos = (pos[0]-scaled_size/2, pos[1]-scaled_size/2)
        Rectangle(pos=centered_pos, size=(scaled_size,scaled_size))
        #Ellipse(pos=centered_pos, size=(scaled_size,scaled_size))

    def draw_borders(self):
        thickness = 2
        
        orig = (self.hoff, self.voff)
        right = self.transform_loc_raw((180, 0))
        right = (right[0]-thickness, right[1])
        top = self.transform_loc_raw((0, 90))
        top = (top[0], top[1]-thickness)
        
        Color(0.5, 0.5, 0.5, mode='rgb')
        Rectangle(pos=orig, size=(right[0]-orig[0], thickness))

#        Color(0, 0, 0, mode='rgb')
#        Rectangle(pos=orig, size=(right[0]-orig[0], -1000000))

        
        Color(0.5, 0.5, 0.5, mode='rgb')
        Rectangle(pos=orig, size=(thickness, top[1]-orig[1]))

        Color(0.5, 0.5, 0.5, mode='rgb')
        Rectangle(pos=right, size=(thickness, top[1]-orig[1] + thickness))
        
        Color(0.5, 0.5, 0.5, mode='rgb')
        Rectangle(pos=top, size=(right[0]-orig[0] + thickness, thickness))


    def draw_connections(self, broker):
        pos_raw = broker['loc']
        pos = self.transform_loc(pos_raw)
        if broker['conns'] == None:
            return
        for node_id in broker['conns']:
            conn_broker = find_broker(node_id)
            if conn_broker == None:
                continue
            if conn_broker['node_id'] == broker['node_id']:
                continue
            if 'local_registry' in conn_broker['mach_type']:
                continue
            
            node_pos_raw = conn_broker['loc']
            node_pos = self.transform_loc(node_pos_raw)

            # TODO: clean up this terrible if statement
            if (selected_broker and
                ((broker['node_id'] == selected_broker['node_id']) or
                 (conn_broker['node_id'] == selected_broker['node_id']))):
                Color(245/255, 223/255, 187/255, mode='rgb')
            else:    
                Color(86/255, 44/255, 44/255, mode='rgb')
            
                
            Line(points=(pos[0], pos[1], node_pos[0], node_pos[1]))
            
            # display distances
            if display_distances:
                center_pos = ((pos[0]+node_pos[0])/2, (pos[1]+node_pos[1])/2)
                text_content = "{}".format(geo2Distance_old(pos_raw, node_pos_raw)/100_000.0)
                label = CoreLabel(text=text_content, font_size=(20*rect_scale))
                label.refresh()
                text = label.texture
                Color(1, 1, 1, mode='rgb')
                self.canvas.add(Rectangle(size=text.size, pos=center_pos, texture=text))
                
                
    def draw_brokers(self):
        # Loop done twice to enforce drawing order.
        if display_connections:
            for broker in all_brokers:
                if 'device' in broker['mach_type']:
                    self.draw_connections(broker)
                    
        self.draw_centered_square((self.dbgx, self.dbgy), (214, 149, 148), 75)
    
        updated_boxes = []
        for broker in all_brokers:
            if broker['mach_type'] == 'global_registry':
                continue
            
            position = self.transform_loc(broker['loc'])
            
            if 'device' in broker['mach_type']:
                updated_boxes.append({
                    'position': position,
                    'size': 25,
                    'broker': broker})
                self.draw_centered_square(position, (14, 149, 148), 25)
            elif 'fog' in broker['mach_type']:
                updated_boxes.append({
                    'position': position,
                    'size': 50,
                    'broker': broker})
                if broker['self_host']:
                    self.draw_centered_square(position, (245, 223, 187), 70)
                self.draw_centered_square(position, (242, 84, 45), 50)
        self.bounding_boxes = updated_boxes
#            elif broker['mach_type'] == 'local_registry':

    # Update our default Scaling.
    def on_resize(self, window, width, height):
        #TODO: refactor to be consistent use v and h 
        wscale = width/WORLD_END_X 
        hscale = height/WORLD_END_Y
        self.width = width
        self.height = height

        # choose the smallest
        if(wscale < hscale):
            self.underlying_scale = wscale
            self.voff = (height - wscale*WORLD_END_Y)/2
            self.hoff = 0
        else:
            self.underlying_scale = hscale
            self.hoff = (width - hscale*WORLD_END_X)/2
            self.voff = 0
        global loc_scale
        loc_scale = self.underlying_scale # TODO: cleanup
        
    def on_mouse_down(self, window, x, y, button, modifiers):
 
        # convert from window space to screenspace.
        global selected_broker

        sx = x
        sy = self.height-y
        
        print(x,y)
        self.dbgx = sx
        self.dbgy = sy
        
        for box in self.bounding_boxes:
            # Note I think the coordinate system is based from top left so this
            # might all be mislabelled
            
            right = box['position'][0] + box['size']*rect_scale/2
            left = box['position'][0] - box['size']*rect_scale/2
            
            top = box['position'][1] + box['size']*rect_scale/2
            bottom = box['position'][1] - box['size']*rect_scale/2
            
            if (bottom < sy < top) and (left < sx < right):
                selected_broker = box['broker']
                return
                
        selected_broker = None
        
    def handle_input(self, delta_time):
        global pressed_keys
        global loc_scale
        global rect_scale
        
        if pressed_keys.get('=', False):
            loc_scale  += 0.0001 * delta_time
            rect_scale += 0.1 * delta_time
        elif pressed_keys.get('-', False):
            loc_scale  -= 0.0001 * delta_time 
            rect_scale -= 0.1 * delta_time
        elif pressed_keys.get(']', False):
            rect_scale += 0.1 * delta_time
        elif pressed_keys.get('[', False):
            rect_scale -= 0.1 * delta_time

            
    def update(self, delta_time):
        self.canvas.clear()
        self.cycles += 1
        self.cycles_this_sec += 1
        if self.last_sec - time.time() > 1:
            self.last_sec = time.time()
            
        
        self.handle_input(delta_time)
        global all_brokers
        with self.canvas:
            self.draw_brokers()
            self.draw_borders()
            
    def _keyboard_closed(self):
        self._keyboard.unbind(on_key_down=self._on_keyboard_down)
        self._keyboard.unbind(on_key_up=self._on_keyboard_up)
        self._keyboard = None

    def _on_keyboard_up(self, keyboard, keycode):
        global pressed_keys

        pressed_keys[keycode[1]] = False
        

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        global pressed_keys

        pressed_keys[keycode[1]] = True
                

        if keycode[1] == 'r':
            reloadNetworkState()
        elif keycode[1] == 'd':
            global display_distances
            display_distances = not display_distances
        elif keycode[1] == 'c':
            global display_connections
            display_connections = not display_connections
        elif keycode[1] == 'q':
            cleanup_exit()
        return True
            
class mobility_display(App):
    def build(self):
        canvas = main_canvas()
        Clock.schedule_interval(canvas.update, 1.0 / 60.0)
        return canvas

def reloadNetworkState():
    print("Reloading Network State")
    global all_brokers
    for broker in all_brokers:
        broker['client'].disconnect()
    all_brokers = []
    recursiveFindNodes("127.0.0.1", 18830, "global_registry", "", {"lat":0,"long":0})
    
def on_connect(client, usr, flag, rc):
    print("Connected to client "+usr)
    client.subscribe(appName + "/local_registry/#")
#    client.subscribe(appName + "/fog/+/status")
    client.subscribe(appName + "/fog/#")
    client.subscribe(appName + "/device/#")
#    client.subscribe(appName + "/device/+/curLoc")


def find_broker(node_id):
    for broker in all_brokers:
        if broker['node_id'] == node_id:
            return broker
    return None
    

# Just matching by port... not very good.
def on_message(client, userdata, message):
    global all_brokers
    branches = message.topic.split('/')
    mach_type = branches[1]
    node_id = branches[2]
    
    if len(message.payload) == 0:
        return
    
    if branches[-1] == "status":
        print(message.payload)
        msg = json.loads(message.payload)
        payload = msg['payload']
            
        broker = find_broker(node_id)

        if payload == "offline":
            if broker != None:
                if mach_type in broker['mach_type']:
                    broker['mach_type'].remove(mach_type)
                all_brokers = list(filter(lambda broker: len(broker['mach_type']) > 0, all_brokers))
            return
        if broker != None:
            if not (mach_type in broker['mach_type']):
                broker['mach_type'].append(mach_type)
            print(broker)
            return
                
        recursiveFindNodes(payload['ip'], payload['port'], mach_type, branches[2], payload['loc'])
    elif branches[-1] == "curLoc":
        msg = json.loads(message.payload)
        broker = find_broker(node_id)
        if broker != None:
            broker['loc']['long'] = msg['payload']['long']
            broker['loc']['lat'] = msg['payload']['lat']
    elif branches[-1] == "_debug_selfhost":
        print("Self host notif!!!")
        msg = json.loads(message.payload)
        broker = find_broker(node_id)
        if broker != None:
            broker['self_host'] = msg
    elif branches[-1] == "_debug_conns":
        msg = json.loads(message.payload)
        broker = find_broker(node_id)
        if broker != None:
            broker['conns'] = msg['payload']

# Discover all the brokers
def recursiveFindNodes(url, port, mach_type, node_id, location):
    global all_brokers
    global remote_tunnels
    global remote_host
    global remote_connection
    global remote_tunnel_context_stack
    
    real_url = url
    if remote_host:
        real_url = "localhost"
        print("semi BRUH!")
        if port not in remote_tunnels:
            print("BRUH!")
            remote_tunnel_context_stack.enter_context(remote_connection.forward_local(port))
            #remote_connection.forward_local(port)
            remote_tunnels.append(port)
            
    
    client = mqtt.Client(userdata=node_id) 
    broker = {
        "client": client,
        "url": f'{url}:{port}',
        "port": port,
        "mach_type": [mach_type],
        "node_id": node_id,
        "self_host": False,
        "conns": None,
        "loc": location
        }
    all_brokers.append(broker)
        
    client.on_connect = on_connect
    client.on_message = on_message
    print(real_url +" bruh "+str(port))
    client.connect(real_url, port)
    client.loop_start()
    



if __name__ == '__main__':
    # Instantiate the parser
    parser = argparse.ArgumentParser(description='Optional app description')
    parser.add_argument('--remote', '-r', type=str)
    args = parser.parse_args()
    if(args.remote):
        remote_host = args.remote
        remote_connection = Connection(remote_host)
        with ExitStack() as stack:
            remote_tunnel_context_stack = stack
            remote_tunnel_context_stack.enter_context(remote_connection.forward_local(18830))
            remote_tunnels.append(18830)
            recursiveFindNodes("127.0.0.1", 18830, "global_registry", "", {"lat":0,"long":0})
            mobility_display().run()
    else:
        recursiveFindNodes("127.0.0.1", 18830, "global_registry", "", {"lat":0,"long":0})
        mobility_display().run()


# We can bind the remote server to a local address
# Then we can do a translation between the remote server and our local binding

# So we need a table of bindings 


