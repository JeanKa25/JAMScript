#!/usr/bin/env python
import kivy
from kivy.app import App
from kivy.uix.widget import Widget
from kivy.uix.label import Label
from kivy.graphics import Color, Rectangle, Line
from kivy.clock import Clock
from kivy.core.window import Window
from kivy.core.text import Label as CoreLabel

import argparse
import paho.mqtt.client as mqtt
import json
import math

from fabric import Connection
import time
import cartopy.crs as ccrs

#appName = "qwe"
appName = "jt1"

all_brokers = []

loc_scale = 1/10000
#loc_scale = 1/1000
#loc_scale = 10
rect_scale = 1

display_distances = False
display_connections = True

pressed_keys = {}

world_offset = (50,50)

# Choosing robinson projection
geodetic = ccrs.Geodetic()
robinson = ccrs.Robinson()

remote_host = None
remote_tunnels = []
remote_connection = None

def geo2Distance_STANK(pos1,pos2):
    return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1]))

def geo2Distance(pos1,pos2):
    lon1 = math.radians(pos1[0])
    lat1 = math.radians(pos1[1])
    lon2 = math.radians(pos2[0])
    lat2 = math.radians(pos2[1])
    
    R = 6378.137

    dist = math.acos(math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon2 - lon1)) * R
    return dist * 1000

def geo2Distance_old(pos1,pos2):
    lon1 = pos1[0]
    lat1 = pos1[1]
    lon2 = pos2[0]
    lat2 = pos2[1]
    
    R = 6378.137
    dLat = lat2 * math.pi / 180 - lat1 * math.pi / 180
    dLon = lon2 * math.pi / 180 - lon1 * math.pi / 180
    a = math.sin(dLat/2) * math.sin(dLat/2) + math.cos(lat1 * math.pi / 180) * math.cos(lat2 * math.pi / 180) * math.sin(dLon/2) * math.sin(dLon/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d * 1000;

class main_canvas(Widget):
    def __init__(self, **kwargs):
        super(main_canvas, self).__init__(**kwargs)
        self.var = 0
        self._keyboard = Window.request_keyboard(self._keyboard_closed, self)
        self._keyboard.bind(on_key_down=self._on_keyboard_down)
        self._keyboard.bind(on_key_up=self._on_keyboard_up)


    def draw_centered_square(self, pos, colour, size):
        scaled_size = size*rect_scale
        Color(colour[0], colour[1], colour[2], mode='rgb')
        centered_pos = (pos[0]-scaled_size/2, pos[1]-scaled_size/2)
        Rectangle(pos=centered_pos, size=(scaled_size,scaled_size))

    def draw_borders(self):
        position = robinson.transform_point(180, 0, geodetic)
        position = (position[0]*loc_scale, position[1]*loc_scale)
        Color(0.5, 0.5, 0.5, mode='rgb')
        Rectangle(pos=position, size=(500000*rect_scale,50000*rect_scale))
        position = robinson.transform_point(0, 90, geodetic)
        position = (position[0]*loc_scale, position[1]*loc_scale)
        Color(0.5, 0.5, 0.5, mode='rgb')
        Rectangle(pos=position, size=(500000*rect_scale,50000*rect_scale))

    def draw_connections(self, broker):
        pos_raw = (broker['loc']['long'],broker['loc']['lat'])
        pos = robinson.transform_point(pos_raw[0], pos_raw[1], geodetic)
        pos = (pos[0]*loc_scale, pos[1]*loc_scale)
        
        if broker['conns'] == None:
            return
        for node_id in broker['conns']:
            conn_broker = find_broker(node_id)
            if conn_broker == None:
                continue
            if conn_broker['node_id'] == broker['node_id']:
                continue
            
            node_pos_raw = (conn_broker['loc']['long'],conn_broker['loc']['lat'])
            node_pos = robinson.transform_point(node_pos_raw[0], node_pos_raw[1], geodetic)
            node_pos = (node_pos[0]*loc_scale, node_pos[1]*loc_scale)

            
            Color(0.8, 0.2, 0, mode='rgb')
            Line(points=(pos[0], pos[1], node_pos[0], node_pos[1]))

            
            # display distance pls
            if display_distances:
                center_pos = ((pos[0]+node_pos[0])/2, (pos[1]+node_pos[1])/2)
                text_content = "{}".format(geo2Distance_old(pos_raw, node_pos_raw)/100_000.0)
                label = CoreLabel(text=text_content, font_size=(20*rect_scale))
                label.refresh()
                text = label.texture
                Color(1, 1, 1, mode='rgb')
                self.canvas.add(Rectangle(size=text.size, pos=center_pos, texture=text))
        

    def draw_brokers(self):
        for broker in all_brokers:
            if broker['mach_type'] == 'global_registry':
                continue
            position_raw = (broker['loc']['long'],broker['loc']['lat'])
            position = robinson.transform_point(position_raw[0], position_raw[1], geodetic)
            position = (position[0]*loc_scale, position[1]*loc_scale)
            
            if 'fog' in broker['mach_type']:
                if broker['self_host']:
                    self.draw_centered_square(position, (0, 0.8, 0.3), 70)
                self.draw_centered_square(position, (1, 0, 0.4), 50)
            elif 'device' in broker['mach_type']:
                self.draw_centered_square(position, (0.2, 0.3, 0.4), 25)
                if display_connections:
                    self.draw_connections(broker)
#            elif broker['mach_type'] == 'local_registry':

    def handle_input(self, delta_time):
        global pressed_keys
        global loc_scale
        global rect_scale
        
        if pressed_keys.get('=', False):
            loc_scale  += 0.0001 * delta_time
            rect_scale += 0.1 * delta_time
        elif pressed_keys.get('-', False):
            loc_scale  -= 0.0001 * delta_time 
            rect_scale -= 0.1 * delta_time
        elif pressed_keys.get(']', False):
            rect_scale += 0.1 * delta_time
        elif pressed_keys.get('[', False):
            rect_scale -= 0.1 * delta_time

            
    def update(self, delta_time):
        self.canvas.clear()
        self.var += 1
        self.handle_input(delta_time)
        global all_brokers
        with self.canvas:
            self.draw_brokers()
            self.draw_borders()
            
    def _keyboard_closed(self):
        self._keyboard.unbind(on_key_down=self._on_keyboard_down)
        self._keyboard.unbind(on_key_up=self._on_keyboard_up)
        self._keyboard = None

    def _on_keyboard_up(self, keyboard, keycode):
        global pressed_keys

        pressed_keys[keycode[1]] = False
        

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        global pressed_keys

        pressed_keys[keycode[1]] = True
                

        if keycode[1] == 'r':
            reloadNetworkState()
        elif keycode[1] == 'd':
            global display_distances
            display_distances = not display_distances
        elif keycode[1] == 'c':
            global display_connections
            display_connections = not display_connections
        elif keycode[1] == 'q':
            exit(0)
        return True
            
class mobility_display(App):
    def build(self):
        canvas = main_canvas()
        Clock.schedule_interval(canvas.update, 1.0 / 60.0)
        return canvas

def reloadNetworkState():
    print("Reloading Network State")
    global all_brokers
    for broker in all_brokers:
        broker['client'].disconnect()
    all_brokers = []
    recursiveFindNodes("127.0.0.1", 18830, "global_registry", "", {"lat":0,"long":0})
    
def on_connect(client, usr, flag, rc):
    print("Connected to client "+usr)
    client.subscribe(appName + "/local_registry/#")
#    client.subscribe(appName + "/fog/+/status")
    client.subscribe(appName + "/fog/#")
    client.subscribe(appName + "/device/#")
#    client.subscribe(appName + "/device/+/curLoc")


def find_broker(node_id):
    for broker in all_brokers:
        if broker['node_id'] == node_id:
            return broker
    return None
    

# Just matching by port... not very good.
def on_message(client, userdata, message):
    global all_brokers
    branches = message.topic.split('/')
    mach_type = branches[1]
    node_id = branches[2]
    
    if len(message.payload) == 0:
        return
    
    if branches[-1] == "status":
        print(message.payload)
        msg = json.loads(message.payload)
        payload = msg['payload']
            
        broker = find_broker(node_id)

        if payload == "offline":
            if broker != None:
                if mach_type in broker['mach_type']:
                    broker['mach_type'].remove(mach_type)
                all_brokers = list(filter(lambda broker: len(broker['mach_type']) > 0, all_brokers))
            return
        if broker != None:
            if not (mach_type in broker['mach_type']):
                broker['mach_type'].append(mach_type)
            print(broker)
            return
                
        recursiveFindNodes(payload['ip'], payload['port'], mach_type, branches[2], payload['loc'])
    elif branches[-1] == "curLoc":
        msg = json.loads(message.payload)
        broker = find_broker(node_id)
        if broker != None:
            broker['loc']['long'] = msg['payload']['long']
            broker['loc']['lat'] = msg['payload']['lat']
    elif branches[-1] == "_debug_selfhost":
        print("Self host notif!!!")
        msg = json.loads(message.payload)
        broker = find_broker(node_id)
        if broker != None:
            broker['self_host'] = msg
    elif branches[-1] == "_debug_conns":
        print("Conns notif!!!")
        msg = json.loads(message.payload)
        broker = find_broker(node_id)
        if broker != None:
            broker['conns'] = msg['payload']

# Discover all the brokers
def recursiveFindNodes(url, port, mach_type, node_id, location):
    global all_brokers
    global remote_tunnels
    global remote_host
    global remote_connection
    
    real_url = url
    if remote_host:
        real_url = "localhost"
        print("semi BRUH!")
        if port not in remote_tunnels:
            print("BRUH!")
            remote_connection.forward_local(port)
            remote_tunnels.append(port)
            
    
    client = mqtt.Client(userdata=node_id) 
    broker = {
        "client": client,
        "url": f'{url}:{port}',
        "port": port,
        "mach_type": [mach_type],
        "node_id": node_id,
        "self_host": False,
        "conns": None,
        "loc": location
        }
    all_brokers.append(broker)
        
    client.on_connect = on_connect
    client.on_message = on_message
    print(real_url +" bruh "+str(port))
    client.connect(real_url, port)
    client.loop_start()
    



if __name__ == '__main__':
    # Instantiate the parser
    parser = argparse.ArgumentParser(description='Optional app description')
    parser.add_argument('--remote', '-r', type=str)
    args = parser.parse_args()
    if(args.remote):
        remote_host = args.remote
        remote_connection = Connection(remote_host)
        with remote_connection.forward_local(18830):
            remote_tunnels.append(18830)
            recursiveFindNodes("127.0.0.1", 18830, "global_registry", "", {"lat":0,"long":0})
    
    mobility_display().run()


# We can bind the remote server to a local address
# Then we can do a translation between the remote server and our local binding

# So we need a table of bindings 
